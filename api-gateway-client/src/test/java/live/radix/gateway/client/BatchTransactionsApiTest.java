/*
 * Radix Gateway API
 * This API is designed to enable clients to efficiently query information on the RadixDLT ledger, and allow clients to simply build and submit transactions to the network.  The API is designed for use by the Radix Foundation's [Desktop Wallet](https://wallet.radixdlt.com/) and [Explorer](https://explorer.radixdlt.com/), and replaces the original Olympia \"Archive Node API\".  # Gateway API Overview  The Gateway API is separated into distinct groupings:  * `/gateway` - Information about the Gateway API status * `/account/_*` - To query account-related information * `/token/_*` - To query token-related information * `/validator/_*` and `/validators` - To query validator-related information * `/transaction/_*` - To build, finalize and submit transactions, and to read the status and content of submitted and on-ledger transactions. * `/custom/_*` - Additional endpoints that are an unofficial extensions to the Gateway API and available only at some API providers (e.g. `https://radix.live`),           or as a custom build from a [forked repository](https://github.com/Radix-Live/radixdlt-network-gateway)  The Gateway API is implemented by the [Network Gateway](https://github.com/radixdlt/radixdlt-network-gateway), which is configured to read from full node/s to extract and index data from the network.  # Gateway API Format  The API is designed in a JSON-RPC style, using HTTP as a transport layer, which means that:  * All requests are POST requests. * Any error is returned with an HTTP status code of 500, with a returned error object.   * The error object contains an HTTP-like `code`   * The error object also contains a structured/typed `details` sub-object, with a `type` discriminator, allowing for structured error interpretation in clients.  # Comparison to other Radix APIs  * [Core API](https://redocly.github.io/redoc/?url=https://raw.githubusercontent.com/radixdlt/radixdlt/main/radixdlt-core/radixdlt/src/main/java/com/radixdlt/api/core/api.yaml) - The Core API is a low level API exposed by full nodes, and designed for use on internal networks. It is primarily designed for network integrations such as exchanges, ledger analytics providers, or hosted ledger data dashboards. The Core API provides endpoints for reading the mempool, constructing transactions and also exposes a stream of committed transactions.  * [System API](https://redocly.github.io/redoc/?url=https://raw.githubusercontent.com/radixdlt/radixdlt/main/radixdlt-core/radixdlt/src/main/java/com/radixdlt/api/system/api.yaml) - The System API is a private API exposed by full nodes to read system status.  The Gateway API offers a much wider range of query options and is more performant than the Core API. It is built on top of the Core API, ingesting data via the Core API transaction stream into a relational database.  The Gateway API transaction/construction endpoints operate with the concept of \"actions\" - these are higher-levels of intent compared with the Core API, which makes it easier for clients to use. The Core API should be used if you require more power/flexiblity for managing UTXOs, or submitting transactions which can't be mapped to a Gateway API action. 
 *
 * The version of the OpenAPI document: 1.1.2-L
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package live.radix.gateway.client;

import live.radix.gateway.ApiException;
import live.radix.gateway.model.ErrorResponse;
import live.radix.gateway.model.TransactionsSinceHashBatchRequest;
import live.radix.gateway.model.TransactionsSinceHashBatchResponse;
import live.radix.gateway.model.TransactionsSinceStateBatchRequest;
import live.radix.gateway.model.TransactionsSinceStateBatchResponse;
import org.junit.Test;
import org.junit.Ignore;
import org.junit.Assert;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for BatchTransactionsApi
 */
@Ignore
public class BatchTransactionsApiTest {

    private final BatchTransactionsApi api = new BatchTransactionsApi();

    /**
     * Batch Polling of new Transactions
     *
     * Returns a list of transactions for each of the requested accounts, that were committed after the requested transaction hash.&lt;br&gt; The transactions are grouped by accounts and ordered by date (oldest first).&lt;br&gt; The pagination is not supported; the clients are expected to perform a new request with updated last seen transaction hashes.&lt;br&gt; If there are no new transactions for one of the specified accounts - it will be omitted from the response.&lt;br&gt; If there are no new transactions for all of the specified accounts - the endpoint will return a successful response with an empty list of AccountTransactions.&lt;br&gt; If there is a transaction that is related to two or more requested accounts - it will be included in the response multiple times - once per each related account.&lt;br&gt; A typical use usage scenario: 1. Execute the request for a list of accounts, without specifying the TX hashes in the request 2. Process the received transactions, store the last seen transaction for each monitored account 3. Execute a new request, this time supply the last seen transaction hashes in the request 4. Process the received transactions, store the last seen transaction for each monitored account 5. Repeat #3-#4 while received TX count &#x3D;&#x3D; limit 6. After some interval (1-5 minutes) - goto #3. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void customTransactionsBatchSinceAccountTransactionsPostTest() throws ApiException {
        TransactionsSinceHashBatchRequest transactionsSinceHashBatchRequest = null;
        TransactionsSinceHashBatchResponse response = api.customTransactionsBatchSinceAccountTransactionsPost(transactionsSinceHashBatchRequest);

        // TODO: test validations
    }
    /**
     * Batch request transactions for multiple accounts.
     *
     * Returns a list of transactions for each of the requested accounts, that were committed after the requested historical ledger state.&lt;br&gt; The transactions are returned in a paginated format, grouped by accounts and ordered by date (oldest first).&lt;br&gt; To get the next page - execute a new request with the \&quot;cursor\&quot; object received in the response.&lt;br&gt; If there are no transactions for one of the specified accounts - it will be omitted from the response.&lt;br&gt; If there are no transactions for all of the specified accounts - the endpoint will still return a successful response with an empty list of AccountTransactions.&lt;br&gt; If there is a transaction that is related to two or more requested accounts - it will be included in the response multiple times - once per each related account.&lt;br&gt;  &#x60;since_state_identifier&#x60; - Transactions from this or any earlier state versions will not be included into the response.&lt;br&gt; &#x60;at_state_identifier&#x60; - The most recent state version to include (inclusive). Optional, by default the most recent observed state will be used.&lt;br&gt; &#x60;cursor&#x60; - The value from the previous page request. If set, overrides &#x60;since_state_identifier&#x60; param.&lt;br&gt; One of [&#x60;since_state_identifier&#x60;, &#x60;cursor&#x60;] is required. 
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void customTransactionsBatchSinceLedgerStatePostTest() throws ApiException {
        TransactionsSinceStateBatchRequest transactionsSinceStateBatchRequest = null;
        TransactionsSinceStateBatchResponse response = api.customTransactionsBatchSinceLedgerStatePost(transactionsSinceStateBatchRequest);

        // TODO: test validations
    }
}
